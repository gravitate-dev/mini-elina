using Animancer;
using Sirenix.OdinInspector;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

/// <summary>
/// Allows this target to get hit and also handles stuntime
/// </summary>
public class FreeFlowTargetable : MonoBehaviour
{
    [InfoBox("To help freeflow attacks hit the target instead of going to the center")]
    public float hitboxRadius;
    public const int HIT_RESULT_NORMAL = 0;
    public const int HIT_RESULT_RAGDOLL = 1;
    public const int HIT_RESULT_STUN = 2;
    public const int HIT_RESULT_DEFEAT = 5;


    public const float SEX_TIME = 7.0f;
    public const float KNOCKDOWN_TIME = 2.7f;
    private const int FREE_STUN_HITS_ALLOWED = 3;

    private List<System.Action> OnDefeatListeners = new List<System.Action>();

    #region === Clean Up Vars ===
    [InfoBox("Make this 99999 if you dont want this enemy to be cleanedup")]
    public float DistanceToCleanUp = 30f;
    private bool CanCleanUp;
    private bool HasCleanedUp;
    private float CheckCleanUpTimer;
    private const float CHECK_CLEAN_UP_TIME = 5.0f;
    #endregion


    [BoxGroup("Attack Stats")]
    public int stuff;

    [BoxGroup("Defense Stats")]
    public int hitsForDefeat = 10;
    [BoxGroup("Defense Stats")]
    public int sexToHitsFactor = 3;
    [BoxGroup("Defense Stats")]
    public int hitsToStun = 8;
    
    [BoxGroup("Stun Settings")]
    public int stunTimeFreeHitsAllowed = 2;
    [BoxGroup("Stun Settings")]
    public float enemyStunTime = 3.0f;
    private float EnemyStunTimer;

    private int stunFreeHitsLeft = 3;
    
    [SerializeField]
    [HideInEditorMode]
    private int currentHits;
    [SerializeField]
    [HideInEditorMode]
    private int currentHitsToStunCountdown;

    public bool defeated = false;
    [HideInEditorMode]
    public bool isSexing;
    public bool isStateStunned;

    private int GO_ID;
    private RagdollEnabler ragdollEnabler;
    private HentaiSexCoordinator hentaiSexCoordinator;
    private EnemyLogic enemyLogic;
    private HybridAnimancerComponent animancer;
    private List<System.Guid> disposables = new List<System.Guid>();
    private float DisableAttackbleTime;
    private float TargetSexableTime;



    // Start is called before the first frame update
    void Start()
    {
        GO_ID = gameObject.GetInstanceID();
        ragdollEnabler = GetComponent<RagdollEnabler>();
        animancer = GetComponent<HybridAnimancerComponent>();
        enemyLogic = GetComponent<EnemyLogic>();
        hentaiSexCoordinator = GetComponent<HentaiSexCoordinator>();
        currentHitsToStunCountdown = hitsToStun;
        disposables.Add(WickedObserver.AddListener(HentaiSexCoordinator.EVENT_STOP_H_MOVE_LOCAL + GO_ID, (move)=>
        {
            HMove temp = (HMove)move;
            isSexing = false;
            if (temp.victim.gameObject.GetInstanceID() == GO_ID)
            {
                // take damage if i am being sexed
                sexHit();
            }
        }));
        // to know while i am being sexed
        disposables.Add(WickedObserver.AddListener("onStartHentaiMove:" + GO_ID, (obj)=>
        {
            if (isSexing) { return; }
            isSexing = true;
            CancelInvoke();
            if (!HentaiSexCoordinator.isPlayerInvolved((HMove)obj))
            {
                Invoke("endSex", SEX_TIME);
            }
        }));

        disposables.Add(WickedObserver.AddListener("OnFreeFlowAnimationFinish:" + GO_ID, (unused) =>
        {
            // reboot an enemy after an attack
            if (enemyLogic != null && !defeated) { enemyLogic.DisableForDuration(0f); }
        }));
    }

    private void Update()
    {
        CheckCleanUpdate();
        if (EnemyStunTimer >= 0)
        {
            EnemyStunTimer -= Time.deltaTime;
            if (EnemyStunTimer <= 0)
            {
                isStateStunned = false;
                //GetComponent<EnemyLogicWrapper>().TryToEnable();
            }
        }
        if (DisableAttackbleTime >= 0)
        {
            DisableAttackbleTime -= Time.deltaTime;
        }
        if (TargetSexableTime >= 0)
        {
            TargetSexableTime -= Time.deltaTime;
        }
    }
    private void OnDestroy()
    {
        WickedObserver.RemoveListener(disposables);
    }
    private void endSex()
    {
        if (this == null)
        {
            return;
        }
        isSexing = false;
        EnableSexable(0);
        DisableAttackble(0);
        hentaiSexCoordinator.StopAllSexIfAny();
    }
    
    public bool isTargetSexable()
    {
        return TargetSexableTime > 0 && !isSexing;
    }

    public void VictimHitRoutines(FreeFlowAttackMove freeFlowAttackMove)
    {
        FreeFlowAttackMove attack = new FreeFlowAttackMove(freeFlowAttackMove);
        if (attack.victim.gameObject.GetInstanceID() == GO_ID)
        {
            // i am victim
            StartCoroutine(onHitRoutines(attack));
        }
    }
    private IEnumerator onHitRoutines(FreeFlowAttackMove move)
    {
        //Wait for attack anim to play
        // disable their attack
        enemyLogic.RestartMovement();
        enemyLogic.DisableForDuration(move.victimAnimationDelay + 0.2f);
        yield return new WaitForSeconds(move.victimAnimationDelay);
        // sad removed it
        //ragdollEnabler.DebugShowOff();

        // normal stun hit time
        if (move.victimReactionId == HIT_RESULT_STUN)
        {
            stun();
        }
        else if (move.victimReactionId == HIT_RESULT_DEFEAT)
        {
            SetToDefeated();
        } else 
        {
            enemyLogic.DisableForDuration(move.victimStunTime);
        }
    }
    
    public void sexHit()
    {
        currentHits += sexToHitsFactor;
        if (currentHits + 1 >= hitsForDefeat)
        {
            SetToDefeated();
        }
    }

    private void SetToDefeated()
    {
        /*DecisionProvider decisionProvider = GetComponent<DecisionProvider>();
        if (decisionProvider != null)
        {
            decisionProvider.defeated = true;
        }*/
        defeated = true;
        /*GetComponent<EnemyLogicWrapper>().TryToDisable();
        GetComponent<HealthSystem>().Die();
*/
        animancer.Play(AnimationClipHandler.INSTANCE.ClipByName("AnimeDeath_FallForward"));
        
        foreach (System.Action action in OnDefeatListeners)
        {
            action.Invoke();
        }

    }
    public int hit(FreeFlowAttackMove attack)
    {
        /*if (attack.attacker.GetComponent<PlayerCheats>().oneHitKill)
        {
            currentHits = 9999;
        }*/
        if (enemyLogic != null && EnemyStunTimer >=0)
        {
            stunFreeHitsLeft--;
            if (stunFreeHitsLeft <= 0)
            {
                EnemyStunTimer = 0;
                isStateStunned = false;
                //GetComponent<EnemyLogicWrapper>().TryToEnable();
                WickedObserver.SendMessage("onStunEndFreePunches:" + GO_ID);
            }
        }
        currentHits++;
        if (currentHits + 1 >= hitsForDefeat)
        {
            SetToDefeated();
            return HIT_RESULT_DEFEAT;
        }
        if (attack.isCounter) {
            return HIT_RESULT_STUN;
        }
        return HIT_RESULT_NORMAL;
    }

    public bool isTargetableForAttack()
    {  
        return !defeated && !isSexing && DisableAttackbleTime < 0;
    }

    private void stun()
    {
        stunFreeHitsLeft = FREE_STUN_HITS_ALLOWED;
        EnableSexable(enemyStunTime);
        isStateStunned = true;
        EnemyStunTimer = enemyStunTime;
        //GetComponent<EnemyLogicWrapper>().TryToDisable();
    }

    public int getCurrentHp()
    {
        return Mathf.Max(0,getMaxHp() + currentHits);
    }

    public int getMaxHp()
    {
        return hitsForDefeat;
    }

    private void DisableAttackble(float duration)
    {
        DisableAttackbleTime = duration;
    }
    private void EnableSexable(float duration)
    {
        TargetSexableTime = duration;
    }

    public void AddOnDefeatListener(System.Action listener)
    {
        OnDefeatListeners.Add(listener);
    }
    #region === Clean Up Routines ===
    /// <summary>
    /// Checks to see if the target should be removed
    /// </summary>
    private void CheckCleanUpdate()
    {
        if (!defeated)
        {
            return;
        }
        if (CheckCleanUpTimer >= 0)
        {
            CheckCleanUpTimer -= Time.deltaTime;
            if (CheckCleanUpTimer <= 0)
            {
                CheckCleanUpTimer = CHECK_CLEAN_UP_TIME;
                if (Vector3.Distance(IAmElina.ELINA.transform.position, transform.position) > DistanceToCleanUp)
                {
                    CleanUpOnce();
                }
            }
        }
    }

    private void CleanUpOnce()
    {
        if (HasCleanedUp || gameObject == null)
        {
            return;
        }
        HasCleanedUp = true;
        Destroy(gameObject);
    }
    #endregion
#if UNITY_EDITOR
    #region === Debug Handle ===
    [Header("Debug Info")]
    public bool DrawHitBoxRadius = false;
    /// <summary>
    /// Visualize values used in <see cref="EnemyLogic"/>
    /// </summary>
    [CustomEditor(typeof(FreeFlowTargetable))]
    public class FreeFlowTargetableHandle : Editor
    {
        FreeFlowTargetable component;
        private int labelsDrawn;
        void OnSceneGUI()
        {
            labelsDrawn = 0;
            component = (FreeFlowTargetable)target;
            if (component == null)
            {
                return;
            }

            if (component.DrawHitBoxRadius)
            {
                DrawRadius(component.hitboxRadius, "Targetable HitBox Radius", Color.red);
            }
        }

        private void DrawRadius(float value, string label, Color color)
        {
            Handles.color = color;
            Vector3 pos = component.transform.position;
            Handles.DrawWireArc(pos,
                component.transform.up,
                -component.transform.right,
                360,
                value);

            GUIStyle style = new GUIStyle();
            style.normal.textColor = color;

            Handles.BeginGUI();
            Vector2 pos2D = HandleUtility.WorldToGUIPoint(pos);
            string msg = label + " = " + value;
            GUI.Label(new Rect(pos2D.x, pos2D.y + (labelsDrawn * 30) + 10, 100, 30), msg, style);
            Handles.EndGUI();

            labelsDrawn += 1;
        }
    }
    #endregion
#endif
}
